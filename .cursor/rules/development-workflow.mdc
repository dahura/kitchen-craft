---
alwaysApply: false
description: Standard developer workflow for starting and completing a task (branching, commits, PR, Linear notes)
---
# Kitchen-Craft Task Workflow

Use this checklist whenever you (or the AI) **start working on a new Linear task**. Follow the steps in order and keep history tidy.

**Status Management:** See [linear-status-management.mdc](mdc:.cursor/rules/linear-status-management.mdc) for automatic Linear status updates at each step.

## 1. Sync `main` (MANDATORY before creating branch)
**CRITICAL:** Always switch to main and pull latest changes before creating a new feature branch.

```bash
git switch main
git pull --ff-only
```

// Memory: Always start with clean main branch to avoid conflicts. This step is MANDATORY.

## 2. Create feature branch
Branch name pattern:
```
feature/KIT-<IssueNumber>-<slugified-title>
```
Examples:
```
feature/KIT-42-fix-validation-crash
feature/KIT-128-room-texture-refactor
```

```bash
git checkout -b feature/KIT-<IssueNumber>-<slugified-title>
```

// Memory: Branch naming convention helps track issues and maintain clean git history

**After creating branch:** Update Linear issue status to `In Progress` and add comment:
```typescript
mcp_Linear_update_issue({
  id: "KIT-XX",
  state: "In Progress"
});
mcp_Linear_create_comment({
  issueId: "KIT-XX",
  body: `[${new Date().toISOString().split('T')[0]}] Started: Created feature branch, analyzing requirements`
});
```
// Memory: Linear status updates keep team informed of progress

## 3. Study the task
• Read description, comments, acceptance criteria.  
• Open related files in IDE.  
• Draft a todo list (_Cursor `todo_write`_).

// Memory: Understanding requirements upfront prevents rework

## 4. Implement changes
• Make **small, incremental commits** (scope = one logical change).  
• **Stage only files touched for this task**: `git add <paths>`.

// Memory: Small commits make code review easier and debugging simpler

## 5. Pause & write local test guide
Before asking for user review, post a message:
> _"Изменения готовы к локальному тесту. Запустите `bun dev` и перейдите на http://localhost:3000. Особое внимание: …"_

// Memory: Clear testing instructions help validate changes efficiently

Wait for user confirmation/feedback.

## 6. Final commit & push
```bash
git commit -m "KIT-<IssueNumber>: <concise summary>"
git push --set-upstream origin $(git branch --show-current)
```
// Memory: Commit messages should reference the issue for traceability

## 7. Create Pull Request (MANDATORY after first push)
**CRITICAL:** After creating a new feature branch and pushing the first commit, immediately create a Pull Request to `main`.

Run:
```bash
gh pr create --base main --fill
```

**Important:** PR should be created as soon as the branch exists, even if work is still in progress. This allows for early feedback and visibility.

// Memory: PRs enable code review and discussion before merging. Create PR immediately after branch creation.

**After creating PR:** Update Linear issue status to `In Review` and add comment with PR link:
```typescript
mcp_Linear_update_issue({
  id: "KIT-XX",
  state: "In Review"
});
mcp_Linear_create_comment({
  issueId: "KIT-XX",
  body: `[${new Date().toISOString().split('T')[0]}] Ready for review: PR #XXX created - <PR_URL>`
});
```

### PR Template (auto-fill)
```
### Linked Issue
KIT-<IssueNumber>

### Change Summary
- Short bullet 1
- Short bullet 2

### Test Instructions
1. bun install (if deps)
2. bun dev
3. Go to http://localhost:3000 and …

### Screenshots / GIF
<optional>

### Checklist
- [ ] Code builds (`bun test` & lint pass)
- [ ] Only task-related files changed
- [ ] Documentation updated if needed
```

## 8. Linear comments as memory log
For long-running tasks, log progress in Linear comments using the pattern:
```
[YYYY-MM-DD] <verb>: <short action>
```
Example:
```
[2025-10-31] Analyzed validator-engine crash root cause
[2025-11-02] Implemented fix + unit tests, awaiting review
```

// Memory: Comments serve as a chronological record of work done

When resuming, **always read latest Linear comments** and continue.

## 9. When User Confirms Fix Works
**Important:** Before updating Linear status, ensure code is committed and pushed:
1. **First:** Commit and push changes (if not already done)
2. **Then:** Update Linear issue status:
   - If PR not created yet: Create PR first, then update to `In Review`
   - If PR exists: Update to `In Review` (if not already)
   - **Never move to `Done` before code is pushed and PR is merged**

```typescript
// After user confirms fix works:
// 1. Ensure: git commit && git push
// 2. Then update status (not Done yet!)
mcp_Linear_update_issue({
  id: "KIT-XX",
  state: "In Review"  // Not Done - wait for PR merge
});
```

// Memory: Always push code before updating Linear status. Done only after PR merge.

## 10. After PR Merge (if applicable)
When PR is merged to main, update Linear issue status to `Done`:
```typescript
mcp_Linear_update_issue({
  id: "KIT-XX",
  state: "Done"
});
mcp_Linear_create_comment({
  issueId: "KIT-XX",
  body: `[${new Date().toISOString().split('T')[0]}] Completed: PR merged, issue resolved`
});
```

// Memory: Final status update closes the loop and marks completion. Done status only after PR merge.

**Note:** Always verify correct status names using `mcp_Linear_list_issue_statuses({ team: "Kitchen-kraft" })`.

## Example Flow

1. User: "Fix KIT-21"
2. **MANDATORY:** AI switches to `main` → `git pull --ff-only`
3. AI creates branch → Updates KIT-21 to `In Progress`
4. AI implements fix → Commits code → Pushes to remote
5. **MANDATORY:** AI creates PR immediately → Updates KIT-21 to `In Review`
6. User confirms fix works → **Ensure code is pushed** → Keep `In Review` (not Done yet!)
7. PR merged → Updates KIT-21 to `Done`

**Critical Rules:**
- **Always** sync `main` before creating a new branch
- **Always** create PR immediately after first push to feature branch
- **Never** move to `Done` before code is pushed and PR is merged

## 11. Memory Bank Guidelines

### Comment Format for Memory
All comments should follow this pattern to serve as effective memory:
```
// Memory: <clear, concise explanation of why this step is important>
```

### What to Document
1. **Decision points**: Why a particular approach was chosen
2. **Workarounds**: Temporary solutions and why they were needed
3. **Dependencies**: What other code/components this change affects
4. **Future considerations**: What might need to be updated later
5. **Testing notes**: Special cases or conditions to verify

### Example Memory Comments
```typescript
// Memory: Using setTimeout instead of setInterval to prevent memory leaks
// Memory: This is a temporary fix until the tall cabinet component is redesigned
// Memory: Must update material-library.ts if adding new material types
// Memory: This component depends on the room-boundary-calculator for positioning
```

### When Resuming Work
1. Read all Linear comments for the issue
2. Check recent commits in the feature branch
3. Review any TODO items left in the code
4. Look for Memory comments explaining previous decisions

This approach ensures continuity of work and prevents repeating mistakes or losing context.